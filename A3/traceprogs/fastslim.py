#!/usr/bin/python

# This program processes an address trace generated by the Valgrind lackey tool
# to create a reduced trace according to the Fastslim-Demand algorithm 
# described in "FastSlim: prefetch-safe trace reduction for I/O cache 
# simulation" by Wei Jin, Xiaobai Sun, and Jeffrey S. Chase in ACM Transactions
# on  Modeling and Computer Simulation, Vol. 11, No. 2 (April 2001), 
# pages 125-160. http://doi.acm.org/10.1145/384169.384170

import fileinput
import sys
import argparse
from operator import attrgetter


class TraceItem:

  def __init__(self, reftype, pg, tstamp):
    self.reftype = reftype
    self.pg = pg
    self.tstamp = tstamp
    self.marked = False

  def __eq__(self, other):
    return self.pg == other.pg

  def __repr__(self):
    return self.reftype + " " + format(self.pg*4096,'x')

  def __hash__(self):
    return hash(self.pg)


ts = 0               # "timestamp" (entry number in original trace)
tracebuffer = set()  # The set of entries in the buffer
toprint = []         # The list of entries waiting to be printed in order

# Emit in timestamp order may have to hold onto items until the trace buffer
# is emptied, because there may be marked items in the trace buffer with 
# earlier timestamps that have to appear in the output first. 
# So, we put entries into a list as they are first seen and then 
# emit_marked adds all marked items to the list. 
# The list is then sorted by timestamp and printed.
def emit_marked_in_ts_order():
  for ti in tracebuffer:
    if ti.marked:
      toprint.append(ti)
  toprint.sort(key=attrgetter('tstamp'))
  for ti in toprint:
    print(ti)
  tracebuffer.clear()
  del toprint[:]

# Parse command line arguments
parser = argparse.ArgumentParser(description="Reduce address trace from valgrind using fastslim-demand algorithm.")
parser.add_argument('-k', '--keepcode', action='store_true', help="include code pages in compressed trace")
parser.add_argument('-b', '--buffersize', type=int, default=4, help="number of entries in trace buffer")
parser.add_argument('tracefile', nargs='?', default="-")
args = parser.parse_args()

# Process input trace
for line in fileinput.input(args.tracefile): 
  if line[0] == '=':
    continue

  reftype = line[0:2].strip()
  if reftype == "I" and args.keepcode == False:
    continue

  addrstr = line.split(',')[0][3:].strip()
  # Hack to address the change from valgrind 3.12 to 3.13 that the 
  # amount of memory that valgrind can use is increased from 64GB
  # 128GB, which causes some addresses to use an extra bit and exceed
  # 36 bits, segfaulting the simulator. Should be robust to any further
  # increases.
  if len(addrstr) >= 10:
      addrstr = addrstr[len(addrstr)-9:]
 
  try:
    addr = int(addrstr, 16)
  except ValueError:
    #print("This does not appear to be valgrind output, skipping: " + line)
    continue

  pg = addr / 4096
  ti = TraceItem(reftype,pg,ts)

  if ti in tracebuffer:
    ti.marked = True
    ti.tstamp = ts
  else:
    if (len(tracebuffer) == args.buffersize):
      emit_marked_in_ts_order()
    toprint.append(ti)
    tracebuffer.add(ti)
  ts = ts + 1
